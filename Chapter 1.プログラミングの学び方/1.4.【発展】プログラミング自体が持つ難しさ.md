# プログラミング自体が持つ難しさ
__※注意：このセクションでは複数箇所でJavaScriptのコードを使って解説を行っています。Chapter 5でJavaScriptの基礎を学習後に読み進めることをおすすめします。__

このセクションではプログラミング学習が難しい理由を言語化し、解明したいと思います。
初学者にとって、プログラミングのコードは古代文字のように見えることでしょう。

「プログラミングは難しい」そう言い放ってしまうのは簡単ですが、それは本当でしょうか？プログラミングは難しいと感じる理由は何でしょうか？
プログラミング教育の専門家であるフェリエンヌ博士は、この問題に認知的な側面からアプローチしました。そして我々はなぜ難しいと感じるのか、どうすればより理解しやすい思考プロセスを辿れるのか、その方法を認知科学の観点から言語化しまとめました。(フェリエンヌ、2021年)

その研究については書籍『プログラマー脳 ～優れたプログラマーになるための認知科学に基づくアプローチ』に詳しくまとめられていますが、その中でもとくに初学者でも応用できる点にアレンジを加えた話をこのセクションでぜひ紹介させてください。

彼女らの研究から解釈すると、プログラミングのコードを読解する際に「難しい」と感じる原因は3種類に分けることが出来ます。このことを把握しそれぞれの対処法を知ることで、プログラミングのコードをより理解しやすくなるでしょう。

## 1. 知識不足
1つの目の理由は、「知らない、知識がない」という状態です。  
例として、まず下記の2つの図を御覧ください。

```
y = x + 5
```

```js
function calculateY(x) {
    return x + 5;
}
```

上の図は一次関数の数式で、下の図はJavaScriptというプログラミング言語のコードです。
おそらく多くの人は上の図が何を意味するかわかるのではないでしょうか？（あるいは忘れているだけで、少し説明を聞いたらすぐ思い出せるはず）
なぜならこれは中学校の数学の授業で誰もが習う内容だからです。

一方で下の図は、多くの人にとって難しく感じるでしょう。
これはJavaScriptという言語で書かれたプログラミングのコードですが、実は上の数式と同じ意味です。
意味が同じでも、例えば`function`が関数を表すキーワードであることや、`return`が関数の実行結果の値を戻り値として返すキーワードであることなど、JavaScriptの仕様を知らなければ、これを理解することはできません。

多くの初学者の方がこれを理解できないのは当然で、知らないから＝学習した経験がないから＝つまりの脳の記憶にないから、ということになります。
すなわち知識不足とは、 __必要な情報が長期記憶に保存されていない状態__ を指します。

### 解決策
この障壁を克服する方法は比較的シンプルで、学習して知識を獲得するほかなりません。
人が知識を獲得するプロセスを言語化すると、以下のようになります。

1. 見たり聞いたりして物事の情報を得る。
2. それを短期記憶に保存する。
3. その後、長期記憶に蓄積する。

短期記憶に蓄積された情報を繰り返し利用することで、それは長期記憶に定着し、知識となります。（反復学習とよく呼ばれます）

ただ、高校までの学校教育とプログラミング学習が大きく違うのは、「100%暗記の必要がない、PCを使うことができる、何度でも実行可能である」点です。
このことはChapter 1.1で触れましたが、プログラミング学習においては、知識を完璧にせずともインデックスしてPCの助けを借りながら引っ張り出せればよいのです。

とはいえ、先の例で言う`function`が`関数`の意味であることを結びつけて記憶するなど、ある程度は暗記しなければならないこともあります。
効果的な記憶術については本題とそれるのであまり触れませんが、エビングハウスの忘却曲線が示すように数日〜数週間にわたり繰り返し復習することで、その記憶は短期記憶から長期記憶へと移行します。
そして反復学習には例えば、フラッシュカード（英単語帳のようなもの）を使うなどの方法が有効です。

ちなみにHTML言語に関していえば、私が開発したiOSアプリにHTMLタグを覚えるフラッシュカードアプリがあります。無料でダウンロードできるので、ぜひ試してみてください。

HTML Cards | App Store
https://apps.apple.com/jp/app/html-cards/id1612679606

## 2. 情報不足
1つ目が長期記憶に関するものであったのに対し、2つ目の原因は短期記憶が関係しています。
”情報”とは、知識と異なり長期記憶に保存される前の状態、すなわち短期記憶にあるデータのことを指します。
短期記憶は数字や記号、文字の並びなどを一時的に脳に保存する役割を持ちます。
例えば英単語や漢字を暗記しようとフラッシュカードで勉強したら、その日1日だけは覚えておくことができるかもしれません。このとき覚えた単語や漢字は、”情報”として短期記憶に保存されている状態です。
”情報”が定着するとそれは長期記憶に移行し、”知識”として保存されます。
情報は比較的容易に取り出すことができますが、長期記憶に移行し知識にならない限りは消えてしまいやすい性質を持ちます。

例として、下記のコードを見てみましょう。

```js
1 function calc_addition(a, b){
2     return a + b;
3 }
4 function calc_remainder(a, b){
5     return a % b;
6 }
7 
8 const result_plus = calc_addition(5, 3);
9 const result_remainder = calc_remainder(10, 3);
10 console.log(result_plus - result_remainder);
```

最終的な実行結果は、10行目の`console.log(result_plus - result_remainder);`で、変数`result_plus`の値から変数`result_remainder`の値を引き算した結果を出力する、というものです。
ここで、コードの詳しい処理内容は考えず、変数名と関数名のみに注目してください。

すると「10行目の`result_plus`」は「8行目の`result_plus`」とイコールであることがわかります。
また、「8行目の`result_plus`」は同じく「8行目の`calc_addition(5,3)`」とイコールであり、「8行目の`calc_addition(5,3)`」は「1行目の`calc_addition(a,b)`」とイコールであることもわかります。

「10行目の`result_remainder`」についても同じことが言えます。つまりこれらは下記のようなイコールの関係があります。
![Alt text](<../Chapter 1.プログラミングの学び方/images/short-memory-2.png>)
![Alt text](<../Chapter 1.プログラミングの学び方/images/short-memory-3.png>)

この、「10行目の`result_plus` = 8行目の`result_plus` = 8行目の`calc_addition(5,3)` = 1行目の`calc_addition(a,b)`」という情報を記憶しておくことが短期記憶の役割です。

### 解決策
これを解決する対策として、フェリエンヌ博士は、変数名や関数名に線を引いたり円で囲み、矢印で関連付けることを提案しています。先に挙げた図表がまさにそれにあたります。

![Alt text](<../Chapter 1.プログラミングの学び方/images/short-memory-2.png>) 
![Alt text](<../Chapter 1.プログラミングの学び方/images/short-memory-3.png>) 
![Alt text](<../Chapter 1.プログラミングの学び方/images/short-memory-4.png>)

こうして図にしすることで、自身の短期記憶の容量を使わずに情報を把握することができるため、理解が容易になります。
ただ、実際にコードにこのように印をつけようと思うと紙に印刷してペンで書き込むなどすることになるわけで、手間がかかります。
そこでおすすめしたいのが、VS CodeやCursorのようなIDE(Chapter 4.2参照)を使う方法です。これらのツール上では、任意のキーワードをダブルクリックするだけで、ファイル上にある同じキーワードをすべてハイライト表示してくれるので、疑似的に先のような状態を再現することが出来ます。

![Alt text](<../Chapter 1.プログラミングの学び方/images/vscode-1.png>) 
![Alt text](<../Chapter 1.プログラミングの学び方/images/vscode-2.png>)

## 3. ワーキングメモリーの限界
最後に3つ目の理由は、ワーキングメモリーの限界からくるものです。
ワーキングメモリとは、作業や動作に必要な情報を一時的に記憶・処理する能力です。
プログラムがどのように実行され、どのような結果が得られるかを理解するプロセスでこの能力が大きく関わってきます。先のコードをもう一度例に解説してみましょう。

```js
1 function calc_addition(a, b){
2     return a + b;
3 }
4 function calc_remainder(a, b){
5     return a % b;
6 }
7 
8 const result_plus = calc_addition(5, 3);
9 const result_remainder = calc_remainder(10, 3);
10 console.log(result_plus - result_remainder);
```

今度は、コードの詳しい処理内容を考えてみましょう。このプログラムの実行結果は何でしょうか？
プロセスを辿ると下記のようになります。

1. Step1：1~3行目で、関数が変数`calc_addition`に格納されていることに気づきます。
2. Step2：8行目で`add_numbers`が呼び出され、その結果が変数`result_plus`に格納されます。
3. Step3：4~6行目で、関数が変数`calc_remainder`に格納されていることに気づきます。
4. Step4：9行目で`calc_remainder`が呼び出され、その結果が変数`result_remainder`に格納されます。
5. Step5：10行目で、`result_plus`と`result_remainder`が引き算され、その結果が`console.log`メソッドで出力されることがわかります。
6. Step6：実行結果として、`(5 + 3) - (10 % 3) = 7`が出力されます。

Chapter 5でJSを一度学習した方であれば、時間がかかるにしてもこのコードを理解することはできるでしょう。
しかしそうだとしても、一度にこの10行のコードを読んだだけで出力結果を予測するのは、それなりに難しいはずです。

ワーキングメモリが十分であれば、これらのStepを頭の中で追って最終結果に到達できますが、不足していると途中のStepで理解が追いつかなくなります。
Step6の結論に至るまでに、Step1～5の動作結果をすべて覚えておく必要があるからです。

ワーキングメモリは短期記憶と役割が同じように見えますが異なるものです。短期記憶は単純に物事を短期的に情報として脳に保持しておくことであるのに対し、ワーキングメモリはその情報を使ってなんからの処理を行う点です。
関数`calc_addition`の実行結果が変数`result_plus`とイコールであることや、関数`calc_remainder`の実行結果が変数`result_remainder`とイコールであるというだけの情報は短期記憶を使いますが、実際に関数内の計算を処理し処理結果脳に保持しながらコードを読み進めるにはワーキングメモリを使います。

![Alt text](<../Chapter 1.プログラミングの学び方/images/memory-diffs.png>)

### 解決策1
限られたワーキングメモリでもコードを理解できるようになるために、プログラミング教育者であるヘルマンズ博士は、問題解決のために「コードをチャンクに分割する」ことを提案しています。
これには「物理的にコードをチャンクに分ける」と「頭の中で分割して理解する」の２つの意味があります。

#### 物理的にコードをチャンクに分ける
多くのプログラミング言語では、さまざまな単位に分けて読みやすくすることができます。例えば読もうとしたコードが30行もの長さで、役割が異なる3つの関数を持っているとしたら、それは複雑で読むのが難しいでしょう。しかし1つの役割しか持たない10行のコードなら読みやすくなります。
（JavaScriptを複数のファイルに分割して管理する方法はChapter 7.4で解説しています。）

![Alt text](<../Chapter 1.プログラミングの学び方/images/split.png>)

#### 頭の中で分割して理解する
もう一つは実際にコードを分けて書くのではなく、プログラムを頭の中で一定の単位に分割して読み進める方法です。
先の例でいえば、関数を定義している箇所(1~6行目)と実行している箇所(8~10行目)に分けて読み進めることができます。

```js
1 function calc_addition(a, b){
2     return a + b;
3 }
4 function calc_remainder(a, b){
5     return a % b;
6 }
```
```js
8 const result_plus = calc_addition(5, 3);
9 const result_remainder = calc_remainder(10, 3);
10 console.log(result_plus - result_remainder);
```

### 解決策2
また、もう1つの解決策として「プランニングから始める」という方法もあります。
具体的には、いきなりコードを書き始めるのではなく、その前に使い慣れた母国語で処理の流れを箇条書きで書いたり、疑似コードを作成します。

例えば先のコードの処理を箇条書きで書くと下記のようになります。

1. 2つの値を足し算する関数を作成する
2. 2つの値で剰余演算する関数を作成する
3. 1から2の値を引く
4. 3の結果を出力する

このように日本語で処理の流れを箇条書きで書くなら、プログラミングができずとも比較的簡単に書きやすいのではないでしょうか。

また、疑似コード(Pseudocode)とは自然言語（この場合は日本語）とプログラミング言語の要素を組み合わせたもので、コーディング前にロジックを設計する段階で用いる下書きのようなものです。
実際の業務で複雑なアルゴリズムをコーディングする際に、頭の中を整理するためにエンジニアが用いたりしますが、初学者がプログラミング学習する上でも役に立つと言われています。(Kinsta, 2023)
先のコードを例に擬似コードを書くと、下記のように記すことが出来ます。

```js
関数 calc_addition(a, b)を定義する
    a と b を加算して結果を返す

関数 calc_remainder(a, b)を定義する
    a を b で割った余りを返す

変数 result_plus に calc_addition(5, 3)の結果を代入する
変数 result_remainder に calc_remainder(10, 3)の結果を代入する

result_plus と result_remainder の差を出力する
```

擬似コードにはこれといって明確な書き方のルールはありませんので、学習者にとってわかりやすい形式で書くことが大切です。
プログラミングは、言うなれば「ロジックを考える処理」と「それをプログラミング言語で翻訳する処理」を同時に脳内で走らせることです。箇条書きや擬似コードはこの処理の内、「ロジックを考える処理」だけ先に終わらせてしまい、そのあとで「それをプログラミング言語で翻訳する処理」を行うという発想です。
これにより、単純計算で言えば同時に消費するワーキングメモリは1/2で済むので、その分理解が容易になるというわけです。