# 非同期処理を可能にするPromiseオブジェクト
Chapter 5.10では`Math`や`Date`などを例に上げながら、標準組み込みオブジェクトについて解説しました。
この標準組み込みオブジェクトの1つに`Promise`というものがあります。とても重要ですが少々複雑な仕様なので、あえてセクションを分けて解説していきます。
このセクションについては半分程度でも理解できれば十分かと思います。Chapter 7のバックエンド実装で少し登場するのでその際にも多少見返していただくといいでしょう。

`Promise`は非同期処理を実装する際に使うオブジェクトで、非同期処理が成功したか失敗したかの情報を返します。
...と一言でまとめてみたものの、この説明ではわけがわからないと思います。順を追って`Promise`を構成する複数の要素や概念について説明させてください。

## 同期処理と非同期処理
先に述べた非同期処理とはそもそも何でしょうか？それについて説明するには、まずは同期処理というものを理解する必要があります。
そもそも、JSは通常上から順番に処理を実行していき、前の処理が完了してから次の処理を実行します。
例えば下記のようなコードがあるとしましょう。

```js
const isTrue = true;
const foo = () => {
    console.log("work A");
}

foo();
for (let i = 0; i < 3; i++) {
  console.log("work B-" + i);
}

if(isTrue === true){
    console.log("work C");
}
```

この場合、コンソールにはどの文字列がどの順番で表示されるでしょうか？
正解は下記の通りです。

```js
// work A
// work B-0
// work B-1
// work B-2
// work C
```

これはシンプルゆえに想像つきやすいのではないでしょうか。実際に上から順に処理が実行され、その際前の処理が完了するのを待ってから次の処理が実行されています。  
このように、 __書かれた順番通りにプログラムが実行されていく仕組を「同期処理」と呼びます。__

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/synchronous.png>)

一方「非同期処理」とは同期処理の正反対で、 __前の処理の完了を待たずに次の処理を実行します。__
例えば、JSには標準組み込み関数に`setTimeout`,`setInterval`,`fetch`などがありますが、これらは非同期処理に該当します。例を示してみましょう。

```js
const isTrue = true;
const foo = () => {
    setTimeout(() => {
        console.log("work A");
    }, 1000);
}

foo();

for (let i = 0; i < 3; i++) {
    console.log("work B-" + i);
}

if(isTrue === true){
    console.log("work C");
}
```

`setTimeout`は、第2引数に指定した時間（ミリ秒）が経過した後、第一引数に設定した処理を実行する関数です。
この場合、コンソールにはどの文字列がどの順番で表示されるでしょうか？正解は下記の通りです。

```js
// work B-0
// work B-1
// work B-2
// work C
// work A
```

もし`setTimeout`が同期処理で実行されるものならば、1000ミリ秒後に`work A`,`work B-0`,`work B-1`,`work B-2`,`work C`の順番で表示されるはずです。
しかし実際には`work B-0` > `work B-1` > `work B-2` > `work C` > `work A`の順番で表示されます。
これは`setTimeout`が非同期で実行される関数だからです。`foo()`が実行されたとき、この処理が完了をするのを待たずして、次の処理である`for`文、`if`文が実行されます。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/asynchronous.png>)

同期処理・非同期処理を並べて図で比較すると下記のようになります。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/synchronous-asynchronous.png>)

## 非同期処理は何に役立つ？
さて、ここまで同期処理と非同期処理について解説しました。そんな非同期処理が一体何に役立つのかというと、主にサーバーサイドとの通信処理です。  
こちらの図を今一度御覧ください。これはChapter 2.4で「HTTPリクエストとHTTPレスポンス」について解説した図です。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/data-flow.png>)

このようにデータの送受信を行う際には、クライアントサイドとサーバーサイドの間でHTTPリクエストとHTTPレスポンスを送受信する必要があります。
JSは標準組み込み関数の`fetch`や、有名どころでいえば`axios`などのライブラリを使うことで、このようなサーバーサイドとの通信処理を行うことが出来ます。（後述）

そしてこれらは”ありがたいことに”非同期処理で実行されます。

サーバーサイドとの通信処理は、異なるプログラム間での連携やインターネットを介す以上、リクエストを送信してからレスポンスを受け取るまでに多少なりとも時間がかかります。  
ユーザーが利用しているインターネットの回線速度や、サーバーサイドのプログラム、また利用されているサーバーのスペックなどさまざまな要因によって、レスポンスを受け取るまでの時間は変わってきます。  

もしこうした処理が同期処理で実行されたとしたら、レスポンスを受け取るまでの間次の処理が実行されず、ユーザーは何も操作できない状態になってしまいます！  
このような事態が続けばユーザー体験は損なわれ、ユーザーはこのアプリケーションを使うことをやめてしまうでしょう。  

しかし、JSの場合は非同期処理によってこれを解決します。
例えば、SNSで投稿に対していいねを送る際、アプリケーションの裏側では「どのユーザーがどの投稿に対していいねを押したかの情報をサーバーサイドに送る」という処理と、その後「その通信が成功したかどうか。また成功した場合にはカウントアップされたいいねの合計値を返す」という処理が行われます。  
しかしユーザーはこの結果を待つことなくなく、他の投稿を見たり、投稿を作成したり、他の投稿にもいいねを押すと言った操作が可能です。

【ユーザーがSNSで同時にいいねや投稿を見たりする図】

## しかし、非同期処理は制御する必要がある
このように、サーバーサイドとの通信処理が非同期処理で行われるのは望ましいことです。  
...が！一方で非同期処理をあたかも同期処理のように制御し、順番に実行したい場合がしばしば発生します。

例えば、「タイムラインを最下部までスクロールすると最新の投稿が即座に表示される機能」は多くのSNSで採用されていますが、これは下記のような処理順で実行されています。

1. 最下部でスクロールされたら、サーバーサイドに最新の投稿を取得するリクエストを送信する
2. 1で取得した投稿を画面に表示する

この処理の順番は絶対にこの順番で実行しなければなりません。というのも、もし1の処理が終わらない間に2が実行された場合、表示させたい投稿のデータをまだ受け取っていない状態なのでエラーとなってしまうからです。  
それを避けるには、非同期処理の実行順を操作し、前の処理が終わってから次の処理を行う...といった実装を行う必要があります。

では具体的にそのような処理をするにはどのようなコードを書けばいいのでしょうか？  
大変お待たせしました。それが`Promise`です。

## Promiseとは
先に少し触れた通り、`Promise`は標準組み込みオブジェクトの1つで非同期処理が完了したことを示す情報を返すことができます。また、`then`や`catch`といったメソッドを持っており、これらを使うことで、非同期処理の成功時・失敗時に続く処理を同期処理のように順序立てて実行することができます。
<!-- コールバック関数 -->

`Promise`は例えば、下記のように書くことができます。

```js
1 const foo = () => {
2    return new Promise((resolve, reject) => {
3       const condition = true; // true or false どちらかを自由に設定
4       if (condition) {
5           resolve("成功");
6       } else {
7           reject("エラー");
8       }
9   });
10 };
11 const handleFulfilled = (resolve) => {
12     console.log(resolve);
13 }
14 const handleRejected = (reject) => {
15     console.log(reject);
16 }
17
18 foo.then((resolve) => {
19     handleFulfilled(resolve);
20 }).catch((reject) => {
21     handleRejected(reject);
22 });

// ↓実行結果
// condition = trueのとき ... "成功エラー"
// condition = falseのとき ... "エラー"
```

### 1~10行目
`Promise`を使って`foo`という非同期関数を実装しています。
この関数では300ミリ秒後に成功またはエラーの結果が返ってくるようになっています。
本来この手の処理はサーバーサイドへの通信が成功したかどうかで結果を返しますが、今回はサンプルコードで柔軟に結果を確認できるようにするため、変数`condition`の値が`true`か`false`かだけを見て処理するようにしています。（3行目）

`resolve`は非同期処理が成功したときに`then`メソッドを呼び出せる`Promise`のメソッドです。（5行目）
また引数には文字列やオブジェクトなどを渡すことができ、渡された値は`then`の引数にを通じてが実行されたときに

、`reject`は非同期処理が失敗したときに


コールバック関数Chapter 5.8

ただし、`Promise`を関数に「加える」とその関数が自動的に非同期関数になるわけではありません。非同期関数とは、`Promise`を返す関数のことを指し、このような関数は、内部で非同期処理（例えば、サーバーへのリクエスト）を行うときに`Promise`を使用します。その後、`.then`や`.catch`を使って、非同期処理の完了後に実行すべき処理をチェーンのようにつなげることができます。

















## then, catch, finally
このように、サーバーサイドとの通信処理が非同期処理で行われるのは望ましいことですが、同期処理のように実行順を制御したい場合がしばしば発生します。
例えば、「タイムラインを最下部までスクロールすると最新の投稿が即座に表示される機能」は多くのSNSで採用されていますが、これは下記のような処理順で実行されています。

1. 最下部でスクロールされたら、サーバーサイドに最新の投稿を取得するリクエストを送信する
2. 1で取得した投稿を画面に表示する

この処理の順番は絶対にこの順番で実行しなければなりません。もし1の処理が終わらない間に2が実行された場合、表示させたい投稿のデータをまだ受け取っていない状態なのでエラーとなってしまいます。
それを避けるには、非同期処理の実行順を操作し、前の処理が終わってから次の処理を行う...といった実装を行う必要があります。
そしてそれを実現するのが`then, catch, finally`です。

`then, catch, finally`構文は、非同期処理を同期処理のように制御するための構文で、`fetch`のようなサーバーサイドとの通信処理を行う非同期の関数と紐づいてよく使われます。  

```js
fetch("https://example.com")
    .then((response) => {
        console.log("リクエストが成功しました。レスポンス内容は「" + response + "」です。");
    })
    .catch((error) => {
        console.log("リクエストが失敗しました。エラー内容は「" + error + "」です。");
    });
    .finally(() => {
        console.log("リクエスト処理が完了しました。");
    });
```

この例では下記の順番で処理が実行されます。
（`barA`,`barB`,`barC`関数はそれぞれ任意の関数名です。）

1. `fetch`関数で`https://example.com`にリクエストを送信する。
2-A. リクエストが成功したら`barA`関数を実行する。
2-B. リクエストが失敗したら`barB`関数を実行する。
3. `barC`関数を実行する。

非同期処理が完了後、`then / catch / finally`はコールバック関数として
通信処理実行後、成功した際に実行したい処理を`then`の中に記述し、失敗した場合に実行したい処理を`catch`の中に記述します。（例えば、ログイン時にパスワードが間違っていた場合エラーを表示する、など。）
`finally`は成功・失敗に関わらず必ず実行したい処理を記述します。

`then`と`catch`はリクエストの成功・失敗結果次第でどちらかのみ実行されますが、`finally`は成功・失敗に関わらず一番最後に必ず実行されます。
とくに必ず実行したい処理がない場合`finally`は省略してもOKですが、`then`と`catch`は両方必ず記述することをおすすめします。

また、`then`はサーバーサイドからのレスポンスが格納されている返り値`response`を返し、`catch`はエラー内容が格納されている返り値`error`を返します。これらを利用し、レスポンス内容に応じて処理を変えることも可能です。
例えばエラーが返ってきた場合にエラーのメッセージ内容を表示させるなどが考えられます。

```js
fetch("https://example.com")
    ...
    .catch((error) => {
        　console.log("エラーが発生しました。エラー内容は「" + error.message + "」です。");
    });
```

しかし、この構文は1つ欠点があります。コードをネストして書くため、連続して行いたい処理がもし複数ある場合には、可読性が悪くなってしまいます。
下記の例では、`fetch`関数で`https://example.com`にリクエストを送信した後、`/step1`というURLにリクエストを送信し、その後`/step2`というURLにリクエストを送信するという処理を行っていますが、ネスト構造が深くなってしまっています。
割愛しましたが、もしここに`catch`を加えるとさらにネスト構造が増えてしまいます。

```js
fetch("https://example.com")
    .then((response) => {
        fetch("https://example.com/step1").then((response) => {
            fetch("https://example.com/step2").then((response) => {
                console.log("全ての処理が完了しました。");
            　});
    })
    .catch((error) => {
        　console.log("エラーが発生しました。エラー内容は「" + error.message + "」です。");
    });
```

ほど複雑なプログラムを書かない限りこのようなネスト構造が深くなることはないと思いますが、一応この欠点は頭の片隅に置いてください。

--- 

【コラム】async / await構文とは
`then / catch / finally`と似たような構文に`async / await`および`try / catch / finally`構構文があります。
`then / catch / finally`構文よりも覚えることが多いのが難点ですが、これらはネスト構造が深くならない書き方ができるため、先に述べたようなデメリットを回避することが出来ます。
本書では詳しくは割愛しますが、JS中〜上級者以上を目指す場合には追々学習することをおすすめします。

- `async`: 関数の前につけることで、その関数を非同期処理にすることができる
- `await`: 非同期処理の前につけることで、その非同期処理が終わるまで次の処理を待機させることができる
- `try / catch / finally`: `try`の中に記述した処理を実行し、エラーが発生した場合は`catch`の中に記述した処理を実行する。`finally`は成功・失敗に関わらず必ず実行する。

コード例）
```js
const foo = async () => {
    try {
        await fetch("https://example.com");
        await fetch("https://example.com/step1");
        await fetch("https://example.com/step2");
        console.log("全ての処理が完了しました。");
    } catch (error) {
        console.log("エラーが発生しました。エラー内容は「" + error.message + "」です。");
    }
}
foo();
```

## 非同期処理の仕組みとPromiseについて



<!-- 

【コラム】Promiseについて  
JSの標準組み込みオブジェクトの1つに`Promise`があります。
そしてJSにおける非同期通信の仕組みは、この`Promise`を利用して実現されます。
`Promise`は非同期処理を行う関数を実行すると、その関数が成功したか失敗したかの情報を返すので、それを利用することで成功時・失敗時に続く処理を実装することが出来ます。
関数を書く際、`Promise`を加えることでその関数は非同期関数になり、成功したか失敗したかの返り値オブジェクトを`then / catch`で受け取れるようになります。

const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("foo");
  }, 300);
});



`fetch`のような標準組み込み関数ははじめから`Promise`を返すようにできています。試しにthenやcatchを使わずconsoleに表示させてみてください。Promiseが表示されるはずです。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/primise.png>)

ので、`then / catch / finally`構文を使わずに`Promise`を利用して非同期処理を実装することも可能です。

```js
new Promise((resolve, reject) => {}
```

```js

--- 
 -->


// ---

// 【コラム】シングルスレッドとマルチスレッド  
// 処理が実行される一連の流れをスレッドと呼びます。同時に1つの処理しか実行できず順番に実行する処理の流れを「シングルスレッド」、同時に複数の処理を実行できる処理の流れを「マルチスレッド」と呼びます。

// シングルスレッドかマルチスレッドかはプログラミング言語の仕様に大きく関わります。  
// 例えばJSはシングルスレッドで実行される言語で、マルチスレッドのような処理を行うにはそれに対応したJavaやGoなどの言語を使う必要があります。  

// JSはシングルスレッドですが、非同期のには先に説明したような非同期処理があるため、シングルスレッドにもかかわらず並列で複数の処理をある程度行うことが出来ます。

// ![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/threads.png>)

// ---