# 非同期処理を可能にするPromiseオブジェクト
Chapter 5.10では`Math`や`Date`などを例に上げながら、標準組み込みオブジェクトについて解説しました。
この標準組み込みオブジェクトの1つに`Promise`というものがあります。とても重要ですが少々複雑な仕様なので、あえてセクションを分けて解説していきます。
このセクションについては半分程度でも理解できれば十分かと思います。Chapter 7のバックエンド実装で少し登場するのでその際にも多少見返していただくといいでしょう。

`Promise`は非同期処理を実装する際に使うオブジェクトで、非同期処理が成功したか失敗したかの情報を返します。
...と一言でまとめてみたものの、この説明ではわけがわからないと思います。順を追って`Promise`を構成する複数の要素や概念について説明させてください。

## 同期処理と非同期処理
先に述べた非同期処理とはそもそも何でしょうか？それについて説明するには、まずは同期処理というものを理解する必要があります。
そもそも、JSは通常上から順番に処理を実行していき、前の処理が完了してから次の処理を実行します。
例えば下記のようなコードがあるとしましょう。

```js
const isTrue = true;
const foo = () => {
    console.log("work A");
}

foo();
for (let i = 0; i < 3; i++) {
  console.log("work B-" + i);
}

if(isTrue === true){
    console.log("work C");
}
```

この場合、コンソールにはどの文字列がどの順番で表示されるでしょうか？
正解は下記の通りです。

```js
// work A
// work B-0
// work B-1
// work B-2
// work C
```

これはシンプルゆえに想像つきやすいのではないでしょうか。実際に上から順に処理が実行され、その際前の処理が完了するのを待ってから次の処理が実行されています。  
このように、 __書かれた順番通りにプログラムが実行されていく仕組を「同期処理」と呼びます。__

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/synchronous.png>)

一方「非同期処理」とは同期処理の正反対で、 __前の処理の完了を待たずに次の処理を実行します。__
例えば、JSには標準組み込み関数に`setTimeout`,`setInterval`,`fetch`などがありますが、これらは非同期処理に該当します。例を示してみましょう。

```js
const isTrue = true;
const foo = () => {
    setTimeout(() => {
        console.log("work A");
    }, 1000);
}

foo();

for (let i = 0; i < 3; i++) {
    console.log("work B-" + i);
}

if(isTrue === true){
    console.log("work C");
}
```

`setTimeout`は、第2引数に指定した時間（ミリ秒）が経過した後、第一引数に設定した処理を実行する関数です。
この場合、コンソールにはどの文字列がどの順番で表示されるでしょうか？正解は下記の通りです。

```js
// work B-0
// work B-1
// work B-2
// work C
// work A
```

もし`setTimeout`が同期処理で実行されるものならば、1000ミリ秒後に`work A`,`work B-0`,`work B-1`,`work B-2`,`work C`の順番で表示されるはずです。
しかし実際には`work B-0` > `work B-1` > `work B-2` > `work C` > `work A`の順番で表示されます。
これは`setTimeout`が非同期で実行される関数だからです。`foo()`が実行されたとき、この処理が完了をするのを待たずして、次の処理である`for`文、`if`文が実行されます。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/asynchronous.png>)

同期処理・非同期処理を並べて図で比較すると下記のようになります。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/synchronous-asynchronous.png>)

## 非同期処理は何に役立つ？
さて、ここまで同期処理と非同期処理について解説しました。そんな非同期処理が一体何に役立つのかというと、主にサーバーサイドとの通信処理です。  
こちらの図を今一度御覧ください。これはChapter 2.4で「HTTPリクエストとHTTPレスポンス」について解説した図です。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/data-flow.png>)

このようにデータの送受信を行う際には、クライアントサイドとサーバーサイドの間でHTTPリクエストとHTTPレスポンスを送受信する必要があります。
JSは標準組み込み関数の`fetch`や、有名どころでいえば`axios`などのライブラリを使うことで、このようなサーバーサイドとの通信処理を行うことが出来ます。（後述）

そしてこれらは”ありがたいことに”非同期処理で実行されます。

サーバーサイドとの通信処理は、異なるプログラム間での連携やインターネットを介す以上、リクエストを送信してからレスポンスを受け取るまでに多少なりとも時間がかかります。  
ユーザーが利用しているインターネットの回線速度や、サーバーサイドのプログラム、また利用されているサーバーのスペックなどさまざまな要因によって、レスポンスを受け取るまでの時間は変わってきます。  

もしこうした処理が同期処理で実行されたとしたら、レスポンスを受け取るまでの間次の処理が実行されず、ユーザーは何も操作できない状態になってしまいます！  
このような事態が続けばユーザー体験は損なわれ、ユーザーはこのアプリケーションを使うことをやめてしまうでしょう。  

しかし、JSの場合は非同期処理によってこれを解決します。
例えば、SNSで投稿に対していいねを送る際、アプリケーションの裏側では「どのユーザーがどの投稿に対していいねを押したかの情報をサーバーサイドに送る」という処理と、その後「その通信が成功したかどうか。また成功した場合にはカウントアップされたいいねの合計値を返す」という処理が行われます。  
しかしユーザーはこの結果を待つことなくなく、他の投稿を見たり、投稿を作成したり、他の投稿にもいいねを押すと言った操作が可能です。

【ユーザーがSNSで同時にいいねや投稿を見たりする図】

## しかし、非同期処理は制御する必要がある
このように、サーバーサイドとの通信処理が非同期処理で行われるのは望ましいことです。  
...が！一方で非同期処理をあたかも同期処理のように制御し、順番に実行したい場合がしばしば発生します。

例えば、「タイムラインを最下部までスクロールすると最新の投稿が即座に表示される機能」は多くのSNSで採用されていますが、これは下記のような処理順で実行されています。

1. 最下部でスクロールされたら、サーバーサイドに最新の投稿を取得するリクエストを送信する
2. 1で取得した投稿を画面に表示する

この処理の順番は絶対にこの順番で実行しなければなりません。というのも、もし1の処理が終わらない間に2が実行された場合、表示させたい投稿のデータをまだ受け取っていない状態なのでエラーとなってしまうからです。  
それを避けるには、非同期処理の実行順を操作し、前の処理が終わってから次の処理を行う...といった実装を行う必要があります。

では具体的にそのような処理をするにはどのようなコードを書けばいいのでしょうか？  
大変お待たせしました。それが`Promise`です。

## Promiseとは
先に少し触れた通り、`Promise`は標準組み込みオブジェクトの1つで非同期処理が完了したことを示す情報を返すことができます。また、`then`や`catch`といったメソッドを持っており、これらを使うことで、非同期処理の成功時・失敗時に続く処理を同期処理のように順序立てて実行することができます。
<!-- コールバック関数 -->

`Promise`は例えば、下記のように書くことができます。

```js
1 const foo = () => {
2    return new Promise((resolve, reject) => {
3       const condition = true; // true or false どちらかを自由に設定
4       if (condition) {
5           resolve("成功");
6       } else {
7           reject("エラー");
8       }
9   });
10 };
11
12 foo.then((resolve) => {
13     console.log(resolve);
14 }).catch((reject) => {
15     console.log(reject);
16 });

// ↓実行結果
// condition = trueのとき ... "成功エラー"
// condition = falseのとき ... "エラー"
```

### 1~10行目
このサンプルコードでは、大まかにはまず`Promise`を使って`foo`という非同期関数を実装しています。
この関数では300ミリ秒後に成功またはエラーの結果が返ってくるようになっています。
本来この手の処理はサーバーサイドへの通信が成功したかどうかなどの判断基準で結果を返しますが、今回はサンプルコードで柔軟に結果を確認できるようにするため、変数`condition`の値が`true`か`false`かだけを見て処理するようにしています。（3行目）

`resolve`は非同期処理が成功したときに`then`メソッドを呼び出せる`Promise`のメソッドです。（5行目）
`resolve`の引数には文字列やオブジェクトなどを渡すことができ、渡された値は`then`メソッドの引数に渡ります。
`reject`は非同期処理が失敗したときに`catch`メソッドを呼び出せる`Promise`のメソッドです。（7行目）
`resolve`同様、`reject`も引数には文字列やオブジェクトなどを渡すことができ、渡された値は`then`メソッドの引数に渡ります。

### 12~16行目
ここでは定義した`foo`関数を実行しています。
1~10行目で`foo`は`Promise`を`return`で返すよう定義しているので、`foo`を実行すると`Promise`が返ってきます。`Promise`は非同期処理が成功・失敗したかの情報を返すと同時に、`then`と`catch`2つのメソッドを続けて書くことができます。

`then`は非同期処理が成功したとき、`catch`は非同期処理が失敗したときの処理をコールバック関数で書くことが出来ます。また、それぞれ`resolve`,`reject`で渡した値を引数に受け取ることが出来るので、これを受け取って成功したときは受け取ったデータを画面に表示させる、失敗したらエラーメッセージを表示させる、などの処理ができます。（コールバック関数に関してはChapter 5.8を参照）

また`then`,`catch`のほか、`finaly`というメソッドもあります。`finally`は非同期処理の成功・失敗に関わらず一番最後に必ず実行されます。

```js
foo.then((resolve) => {
    console.log(resolve);
}).catch((reject) => {
    console.log(reject);
}).finally(() => {
    console.log("リクエスト処理が完了しました。");
});
```

とくに必ず実行したい処理がない場合`finally`は省略してもOKです。
しかし、`then`や`catch`を使う書き方には1つ欠点があります。コードをネストして書くため、連続して行いたい処理がもし複数ある場合には、可読性が悪くなってしまう点です。
下記の例では、`foo`同様に定義した非同期関数`bar`と`baz`を繋げて実行していますが、ネスト構造が深くなってしまっています。

```js
foo.then((resolve) => {
    bar.then((resolve) => {
        baz.then((resolve) => {
            console.log("foo,bar,bazが成功：" + resolve);
        }).catch((reject) => {
            console.log("bazのエラー：" + reject);
        });
    }).catch((reject) => {
        console.log("barのエラー：" + reject);
    });
}).catch((reject) => {
    console.log("fooのエラー：" + reject);
});
```

これを解決する方法として、`await`と`async`を用いた構文で非同期処理を書く方法があります。

## await, asyncと try, catch, finally構文
`await`は非同期処理の前につけることで、その非同期処理が終わるまで次の処理を待機させることができる演算子です。
`async`は関数の前につけることで、その関数を非同期処理として定義することができる演算子です。
`await`は`async`で宣言された関数内でしか実行できないという制限付きのため、実際にはこの2つはセットで使われます。

`Promise`および`then`や`catch`と用途は同じですが、`await`と`async`を使うことの大きなメリットとして、先に述べたようなネスト地獄を回避することができます。

```js
const asyncFunction = async () => {
    await foo();
    await bar();
    await baz();
};
```

また、`await`と`async`を使う場面でよくセットで用いられるものに、`try, catch, finally`構文というものがあります。これは`Promise`の`then, catch, finally`と同じように、非同期処理に成功したとき・失敗したとき・成功・失敗に関わらず実行したい処理をそれぞれ指定することができます。

```js
try {
    // ここに非同期処理を書く
} catch (error) {
    // 非同期処理が失敗したときの処理を書く
} finally {
    // 非同期処理が成功・失敗に関わらず実行したい処理を書く
}
```

これらを用いて、例えば先の非同期関数`foo`,`bar`,`baz`を使った処理は下記のように書き換えることができます。

```js
const asyncFunction = async () => {
    try {
        await foo();
        await bar();
        await baz();
        console.log("foo,bar,bazが成功");
    } catch (error) {
        console.log("foo,bar,bazのどれかが失敗：" + error);
    } finally {
        console.log("リクエスト処理が完了しました。");
    }
};
```

この例では、`foo`,`bar`,`baz`が同期処理のように前の処理が終わるまで待機・順に実行され、すべてが成功した場合には最終的に`console.log("foo,bar,bazが成功");`が実行されます。  
逆にどれか1つが失敗した場合には`catch`の中の処理が実行され、いずれかの処理で実行された`reject`で受け取った引数が`error`に渡ります。  
`finally`は成功・失敗に関わらず一番最後に必ず実行され、同様に省略が可能です。  

いかがでしょう。`then`と`catch`を使ったときと比べていくらか可読性が上がったのではないでしょうか。  
この構文はChapter 7.xでバックエンド実装を行う際に登場するので、その際に改めてコーディングして理解を深めていただければと思います。

## サーバーサイドとの通信を行う非同期処理
こうした非同期処理ですが、`fetch`や`axios`でサーバーサイドとの通信処理ができると先程述べました。  
`axios`についてはライブラリをインストールする手間がかかるので本書では割愛しますが、`fetch`についてはブラウザAPIなのですぐに使うことができます。（ブラウザAPIについてはChapter 5.11で解説）

`fetch`に基本的な使い方は、第一引数にリクエストを送信するURLを指定し、第二引数にオプションを指定します。
オプションにはリクエストのHTTPメソッドやヘッダー情報、リクエストボディなどを指定することができますが、何を設定するかは通信先のサーバーサイドのプログラムの仕様に左右されます。  
オプションを省略した単純な例を示すと下記のようになります。（URLは適当な値です）

```js
fetch("https://example.com");
```
`fetch`は内部的には`Promise`を返す非同期関数です。そのため先にご紹介した非同期関数のように、`then`や`catch`とともに処理を書くことが出来ます。

```js
fetch("https://example.com")
    .then((response) => {
        console.log("リクエストが成功しました。レスポンス内容は「" + response + "」です。");
    })
    .catch((error) => {
        console.log("リクエストが失敗しました。エラー内容は「" + error + "」です。");
    });
    .finally(() => {
        console.log("リクエスト処理が完了しました。");
    });
```

また`await`,`async`を使った構文で書くこともできます。

```js
const foo = async () => {
    try {
        await fetch("https://example.com");
        await fetch("https://example.com/step1");
        await fetch("https://example.com/step2");
        console.log("全ての処理が完了しました。");
    } catch (error) {
        console.log("エラーが発生しました。エラー内容は「" + error.message + "」です。");
    }
}
foo();
```

Chapter 7のバックエンド実装では実際にサーバーサイドからデータを受け取り、HTMLページに表示させるところまでを実装するので、ぜひそちらで実際の処理をコーディングして試してみてください。