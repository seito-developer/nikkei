# 同期処理と非同期処理
通常、JSは上から順番に処理を実行していき、前の処理が完了してから次の処理を実行します。
例えば下記のようなコードがあるとしましょう。

```js
const isTrue = true;
const foo = () => {
    console.log("work A");
}

foo();
for (let i = 0; i < 3; i++) {
  console.log("work B-" + i);
}

if(isTrue === true){
    console.log("work C");
}
```

この場合、コンソールにはどの文字列がどの順番で表示されるでしょうか？
正解は下記の通りです。

```js
// work A
// work B-0
// work B-1
// work B-2
// work C
```
これはとてもシンプルで、上から順に処理が実行されていることがわかります。
このように上から順に処理を実行していくことを「同期処理」と呼びます。JSにおける処理はほとんどこのパターンです。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/synchronous.png>)

一方で、「非同期処理」と呼ばれるものも存在します。
これは同期処理の正反対で、前の処理を待たずに次の処理を実行します。
例えば、JSには標準組み込み関数に`setTimeout`,`setInterval`,`fetch`などがありますが、これらは非同期処理に該当します。例を示してみましょう。

```js
const isTrue = true;
const foo = () => {
    setTimeout(() => {
        console.log("work A");
    }, 1000);
}

foo();

for (let i = 0; i < 3; i++) {
    console.log("work B-" + i);
}

if(isTrue === true){
    console.log("work C");
}
```
`setTimeout`は、第2引数に指定した時間（ミリ秒）が経過した後、第一引数に設定した処理を実行する関数です。
この場合、コンソールにはどの文字列がどの順番で表示されるでしょうか？
正解は下記の通りです。

```js
// work B-0
// work B-1
// work B-2
// work C
// work A
```

もし`setTimeout`が同期処理で実行されるものならば、1000ミリ秒後に`work A`,`work B-0`,`work B-1`,`work B-2`,`work C`の順番で表示されるはずです。
しかし実際には`work B-0`,`work B-1`,`work B-2`,`work C`,`work A`の順番で表示されます。
これは`setTimeout`が非同期で実行される関数だからです。`foo()`が実行されたとき、この処理が完了をするのを待たずして、次の処理である`for`文、`if`文が実行されます。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/asynchronous.png>)

同期処理・非同期処理を並べて図で比較すると下記のようになります。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/synchronous-asynchronous.png>)

---

【コラム】シングルスレッドとマルチスレッド
このような一連の処理の流れをスレッドと呼び、同時に1つの処理しか実行できず順番に実行する処理の流れを「シングルスレッド」、同時に複数の処理を実行できる処理の流れを「マルチスレッド」と呼びます。

シングルスレッドかマルチスレッドかはプログラミング言語の仕様に大きく関わります。  
例えばJSはシングルスレッドで実行される言語ですので、マルチスレッドのような処理を行うにはそれに対応したJavaやGoなどの言語を使う必要があります。  
しかし、JSには先に説明したような非同期処理があるため、シングルスレッドにもかかわらず並列で複数の処理をある程度行うことが出来ます。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/threads.png>)

同期・非同期の仕組みを理解して扱うのは難しいですが、非同期通信を加えることで並列に複数の処理を走らせることが出来るため、より高速な処理をさせるなど高度なプログラミングを行うことができるようになります。

---

## 非同期処理はとくにサーバーサイドとの通信処理に役立つ
非同期処理について説明する上で欠かせないのが、サーバーサイドとの通信処理です。
こちらの図を今一度御覧ください。これはChapter 2.4で「HTTPリクエストとHTTPレスポンス」について解説した図です。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/data-flow.png>)

このようにデータの送受信を行う際には、クライアントサイドとサーバーサイドの間でHTTPリクエストとHTTPレスポンスを送受信する必要があります。
JSは標準組み込み関数の`fetch`や、有名どころでいえば`axios`などのライブラリを使うことで、このようなサーバーサイドとの通信処理を行うことが出来ます。

そしてこれらは __ありがたいことに__ 非同期処理にあたります。というのも、サーバーサイドとの通信処理は、サーバーサイドにリクエストを送信してからレスポンスを受け取るまでに時間がかかります。  
ユーザーが利用しているインターネットの回線速度や、サーバーサイドのプログラム、また利用されているサーバーのスペックなどさまざまな要因によって、レスポンスを受け取るまでの時間は変わってきます。  
もしこうした処理が同期処理で実行されたとしたら、レスポンスを受け取るまでの間次の処理が実行されず、ユーザーは何も操作できない状態になってしまいます。このような事態が続けばユーザー体験は損なわれ、ユーザーはこのアプリケーションを使うことをやめてしまうでしょう。  

JSの場合はこのような非同期処理をクライアントサイドから行うことができるため、ユーザーがレスポンスを待っている間にも他の処理を止めることなく並列で行うことで、快適なユーザー体験を提供することが出来ます。  
例えば、SNSで投稿に対していいねを送る際、アプリケーションの裏側では「どのユーザーがどの投稿に対していいねを押したかの情報をサーバーサイドに送る」という処理と、その後「その通信が成功したかどうか。また成功した場合にはカウントアップされたいいねの合計値を返す」という処理が行われます。  
しかしユーザーはこの結果を待つことなくなく、他の投稿を見たり、投稿を作成したり、他の投稿にもいいねを押スと言った操作が可能です。

## then, catch, finally
このように、サーバーサイドとの通信処理が非同期処理で行われるのは望ましいことですが、同期処理のように実行順を制御したい場合がしばしば発生します。
例えば、「タイムラインを最下部までスクロールすると最新の投稿が即座に表示される機能」は多くのSNSで採用されていますが、これは下記のような処理順で実行されています。

1. 最下部でスクロールされたら、サーバーサイドに最新の投稿を取得するリクエストを送信する
2. 1で取得した投稿を画面に表示する

この処理の順番は絶対にこの順番で実行しなければなりません。もし1の処理が終わらない間に2が実行された場合、表示させたい投稿のデータをまだ受け取っていない状態なのでエラーとなってしまいます。
それを避けるには、非同期処理の実行順を操作し、前の処理が終わってから次の処理を行う...といった実装を行う必要があります。
そしてそれを実現するのが`then, catch, finally`です。

`then, catch, finally`構文は、非同期処理を同期処理のように制御するための構文で、`fetch`のようなサーバーサイドとの通信処理を行う非同期の関数と紐づいてよく使われます。  

```js
fetch("https://example.com")
    .then((response) => {
        console.log("リクエストが成功しました。レスポンス内容は「" + response + "」です。");
    })
    .catch((error) => {
        console.log("リクエストが失敗しました。エラー内容は「" + error + "」です。");
    });
    .finally(() => {
        console.log("リクエスト処理が完了しました。");
    });
```

この例では下記の順番で処理が実行されます。
（`barA`,`barB`,`barC`関数はそれぞれ任意の関数名です。）

1. `fetch`関数で`https://example.com`にリクエストを送信する。
2-A. リクエストが成功したら`barA`関数を実行する。
2-B. リクエストが失敗したら`barB`関数を実行する。
3. `barC`関数を実行する。

非同期処理が完了後、`then / catch / finally`はコールバック関数として
通信処理実行後、成功した際に実行したい処理を`then`の中に記述し、失敗した場合に実行したい処理を`catch`の中に記述します。（例えば、ログイン時にパスワードが間違っていた場合エラーを表示する、など。）
`finally`は成功・失敗に関わらず必ず実行したい処理を記述します。

`then`と`catch`はリクエストの成功・失敗結果次第でどちらかのみ実行されますが、`finally`は成功・失敗に関わらず一番最後に必ず実行されます。
とくに必ず実行したい処理がない場合`finally`は省略してもOKですが、`then`と`catch`は両方必ず記述することをおすすめします。

また、`then`はサーバーサイドからのレスポンスが格納されている返り値`response`を返し、`catch`はエラー内容が格納されている返り値`error`を返します。これらを利用し、レスポンス内容に応じて処理を変えることも可能です。
例えばエラーが返ってきた場合にエラーのメッセージ内容を表示させるなどが考えられます。

```js
fetch("https://example.com")
    ...
    .catch((error) => {
        　console.log("エラーが発生しました。エラー内容は「" + error.message + "」です。");
    });
```

しかし、この構文は1つ欠点があります。コードをネストして書くため、連続して行いたい処理がもし複数ある場合には、可読性が悪くなってしまいます。
下記の例では、`fetch`関数で`https://example.com`にリクエストを送信した後、`/step1`というURLにリクエストを送信し、その後`/step2`というURLにリクエストを送信するという処理を行っていますが、ネスト構造が深くなってしまっています。
割愛しましたが、もしここに`catch`を加えるとさらにネスト構造が増えてしまいます。

```js
fetch("https://example.com")
    .then((response) => {
        fetch("https://example.com/step1").then((response) => {
            fetch("https://example.com/step2").then((response) => {
                console.log("全ての処理が完了しました。");
            　});
    })
    .catch((error) => {
        　console.log("エラーが発生しました。エラー内容は「" + error.message + "」です。");
    });
```

ほど複雑なプログラムを書かない限りこのようなネスト構造が深くなることはないと思いますが、一応この欠点は頭の片隅に置いてください。

--- 

【コラム】async / await構文とは
`then / catch / finally`と似たような構文に`async / await`および`try / catch / finally`構構文があります。
`then / catch / finally`構文よりも覚えることが多いのが難点ですが、これらはネスト構造が深くならない書き方ができるため、先に述べたようなデメリットを回避することが出来ます。
本書では詳しくは割愛しますが、JS中〜上級者以上を目指す場合には追々学習することをおすすめします。

- `async`: 関数の前につけることで、その関数を非同期処理にすることができる
- `await`: 非同期処理の前につけることで、その非同期処理が終わるまで次の処理を待機させることができる
- `try / catch / finally`: `try`の中に記述した処理を実行し、エラーが発生した場合は`catch`の中に記述した処理を実行する。`finally`は成功・失敗に関わらず必ず実行する。

コード例）
```js
const foo = async () => {
    try {
        await fetch("https://example.com");
        await fetch("https://example.com/step1");
        await fetch("https://example.com/step2");
        console.log("全ての処理が完了しました。");
    } catch (error) {
        console.log("エラーが発生しました。エラー内容は「" + error.message + "」です。");
    }
}
foo();
```

## 非同期処理の仕組みとPromiseについて

JSにおける非同期処理がどのような仕組みで実現されているのか、その説明をする上で`Promise`について言及しないわけには行きません。
`Promise`とはJavaScriptの標準組み込みオブジェクトの1つで、非同期処理の結果を表すオブジェクトです。大まかには、このオブジェクトは非同期操作が成功した場合（「解決」または「fulfilled」と言います）か、失敗した場合（「拒否」または「rejected」と言います）かの情報を持ちます。
この`Promise`オブジェクトを利用することで、非同期処理が成功したとき（`resolve`されたとき）と失敗したとき（`reject`されたとき）に実行する処理を`.then`メソッドと`.catch`メソッドを通じて指定することができます。

この`Promise`を利用することで非同期関数を実装することが出来ます。例えば下記のような書き方ができます。

```js
1 const foo = new Promise((resolve, reject) => {
2   setTimeout(() => {
3     const condition = true; // true or false どちらかを自由に設定
4     if (condition) {
5       resolve("成功");
6     } else {
7       reject("エラー");
8     }
9   }, 300);
10 });
const handleFulfilled = (resolve) => {
    console.log(resolve);
}
const handleRejected = (reject) => {
    console.log(reject);
}

foo.then((resolve) => handleFulfilled(resolve)).catch((reject) => handleRejected(reject));
// ↓実行結果
// condition = trueのとき ... "成功エラー"
// condition = falseのとき ... "エラー"
```

### 1~10行目
`Promise`を使って`foo`という非同期関数を実装しています。
この関数では300ミリ秒後に成功またはエラーの結果が返ってくるようになっています。
本来この手の処理はサーバーサイドへの通信が成功したかどうかで結果を返しますが、今回はサンプルコードで柔軟に結果を確認できるようにするため、変数`condition`の値が`true`か`false`かだけを見て処理するようにしています。（3行目）

`resolve`は非同期処理が成功したときに`then`メソッドを呼び出せる`Promise`のメソッドです。（5行目）
また引数には文字列やオブジェクトなどを渡すことができ、渡された値は`then`の引数にを通じてが実行されたときに

、`reject`は非同期処理が失敗したときに


コールバック関数Chapter 5.8

ただし、`Promise`を関数に「加える」とその関数が自動的に非同期関数になるわけではありません。非同期関数とは、`Promise`を返す関数のことを指し、このような関数は、内部で非同期処理（例えば、サーバーへのリクエスト）を行うときに`Promise`を使用します。その後、`.then`や`.catch`を使って、非同期処理の完了後に実行すべき処理をチェーンのようにつなげることができます。



【コラム】Promiseについて  
JSの標準組み込みオブジェクトの1つに`Promise`があります。
そしてJSにおける非同期通信の仕組みは、この`Promise`を利用して実現されます。
`Promise`は非同期処理を行う関数を実行すると、その関数が成功したか失敗したかの情報を返すので、それを利用することで成功時・失敗時に続く処理を実装することが出来ます。
関数を書く際、`Promise`を加えることでその関数は非同期関数になり、成功したか失敗したかの返り値オブジェクトを`then / catch`で受け取れるようになります。

const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("foo");
  }, 300);
});



`fetch`のような標準組み込み関数ははじめから`Promise`を返すようにできています。試しにthenやcatchを使わずconsoleに表示させてみてください。Promiseが表示されるはずです。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/primise.png>)

ので、`then / catch / finally`構文を使わずに`Promise`を利用して非同期処理を実装することも可能です。

```js
new Promise((resolve, reject) => {}
```

```js

--- 