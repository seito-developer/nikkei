# 同期処理と非同期処理
通常、JSは上から順番に処理を実行していき、前の処理が完了してから次の処理を実行します。
例えば下記のようなコードがあるとしましょう。

```js
const isTrue = true;
const foo = () => {
    console.log("work A");
}

foo();
for (let i = 0; i < 3; i++) {
  console.log("work B-" + i);
}

if(isTrue === true){
    console.log("work C");
}
```

この場合、コンソールにはどの文字列がどの順番で表示されるでしょうか？
正解は下記の通りです。

```js
// work A
// work B-0
// work B-1
// work B-2
// work C
```
これはとてもシンプルで、上から順に処理が実行されていることがわかります。
このように上から順に処理を実行していくことを「同期処理」と呼びます。JSにおける処理はほとんどこのパターンです。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/synchronous.png>)

一方で、「非同期処理」と呼ばれるものも存在します。
これは同期処理の正反対で、前の処理を待たずに次の処理を実行します。
例えば、JSには標準組み込み関数に`setTimeout`,`setInterval`,`fetch`などがありますが、これらは非同期処理に該当します。例を示してみましょう。

```js
const isTrue = true;
const foo = () => {
    setTimeout(() => {
        console.log("work A");
    }, 1000);
}

foo();

for (let i = 0; i < 3; i++) {
    console.log("work B-" + i);
}

if(isTrue === true){
    console.log("work C");
}
```
`setTimeout`は、第2引数に指定した時間（ミリ秒）が経過した後、第一引数に設定した処理を実行する関数です。
この場合、コンソールにはどの文字列がどの順番で表示されるでしょうか？
正解は下記の通りです。

```js
// work B-0
// work B-1
// work B-2
// work C
// work A
```

もし`setTimeout`が同期処理で実行されるものならば、1000ミリ秒後に`work A`,`work B-0`,`work B-1`,`work B-2`,`work C`の順番で表示されるはずです。
しかし実際には`work B-0`,`work B-1`,`work B-2`,`work C`,`work A`の順番で表示されます。
これは`setTimeout`が非同期で実行される関数だからです。`foo()`が実行されたとき、この処理が完了をするのを待たずして、次の処理である`for`文、`if`文が実行されます。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/asynchronous.png>)

同期処理・非同期処理を並べて図で比較すると下記のようになります。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/synchronous-asynchronous.png>)

---

【コラム】シングルスレッドとマルチスレッド
このような一連の処理の流れをスレッドと呼び、同時に1つの処理しか実行できず順番に実行する処理の流れを「シングルスレッド」、同時に複数の処理を実行できる処理の流れを「マルチスレッド」と呼びます。

シングルスレッドかマルチスレッドかはプログラミング言語の仕様に大きく関わります。  
例えばJSはシングルスレッドで実行される言語ですので、マルチスレッドのような処理を行うにはそれに対応したJavaやGoなどの言語を使う必要があります。  
しかし、JSには先に説明したような非同期処理があるため、シングルスレッドにもかかわらず並列で複数の処理をある程度行うことが出来ます。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/threads.png>)

同期・非同期の仕組みを理解して扱うのは難しいですが、非同期通信を加えることで並列に複数の処理を走らせることが出来るため、より高速な処理をさせるなど高度なプログラミングを行うことができるようになります。

---

## サーバーサイドとの通信処理
非同期処理について説明する上で欠かせないのが、サーバーサイドとの通信処理です。
こちらの図を今一度御覧ください。これはChapter 2.4で「HTTPリクエストとHTTPレスポンス」について解説した図です。

![Alt text](<../Chapter 5.JavaScriptでプログラミング言語の基礎を学ぼう！/images/data-flow.png>)

このようにデータの送受信を行う際には、クライアントサイドとサーバーサイドの間でHTTPリクエストとHTTPレスポンスを送受信する必要があります。
JSは標準組み込み関数の`fetch`や、有名どころでいえば`axios`などのライブラリを使うことで、このようなサーバーサイドとの通信処理を行うことが出来ます。

そしてこれらは __ありがたいことに__ 非同期処理にあたります。というのも、サーバーサイドとの通信処理は、サーバーサイドにリクエストを送信してからレスポンスを受け取るまでに時間がかかります。
ユーザーが利用しているインターネットの回線速度や、サーバーサイドのプログラム、また利用されているサーバーのスペックなどさまざまな要因によって、レスポンスを受け取るまでの時間は変わってきます。
もしこうした処理が同期処理で実行されたとしたら、レスポンスを受け取るまでの間次の処理が実行されず、ユーザーは何も操作できない状態になってしまいます。このような事態が続けばユーザー体験は損なわれ、ユーザーはこのアプリケーションを使うことをやめてしまうでしょう。

JSの場合はこのような非同期処理をクライアントサイドから行うことができるため、ユーザーがレスポンスを待っている間にも他の処理を止めることなく並列で行うことで、快適なユーザー体験を提供することが出来ます。
例えば、SNSで投稿に対していいねを送る際、アプリケーションの裏側では「どのユーザーがどの投稿に対していいねを押したかの情報をサーバーサイドに送る」という処理と、その後「その通信が成功したかどうか。また成功した場合にはカウントアップされたいいねの合計値を返す」という処理が行われます。
しかしユーザーはこの結果を待つことなくなく、他の投稿を見たり、投稿を作成したり、他の投稿にもいいねを押スと言った操作が可能です。

## then / catch, async / await + try / catch / finally 構文
このように、サーバーサイドとの通信処理が非同期処理で行われるのは望ましいことですが、同期処理のように実行順を制御したい場合がしばしば発生します。
例えば、「タイムラインを最下部までスクロールすると最新の投稿が即座に表示される機能」は多くのSNSで採用されていますが、これは下記のような処理順で実行されています。

1. 最下部でスクロールされたら、サーバーサイドに最新の投稿を取得するリクエストを送信する
2. 1で取得した投稿を画面に表示する

この処理の順番は絶対にこの順番で実行しなければなりません。もし1の処理が終わらない間に2が実行された場合、表示させたい投稿のデータをまだ受け取っていない状態なのでエラーとなってしまいます。
このように、非同期処理を同期処理のように制御して実行したい場合に使える構文があるので、代表的なものを2つご紹介しましょう。

### then / catch / finally 構文
`then / catch / finally`構文は、非同期処理を同期処理のように制御するための構文で、`fetch`のようなサーバーサイドとの通信処理を行う非同期の関数と紐づいてよく使われます。  
通信処理実行後、成功した際に実行したい処理を`then`の中に記述し、失敗した場合に実行したい処理を`catch`の中に記述します。（例えば、ログイン時にパスワードが間違っていた場合エラーを表示する、など。）
`finally`は成功・失敗に関わらず必ず実行したい処理を記述します。

```js
fetch("https://example.com")
    .then((response) => {
        　barA();
    })
    .catch((error) => {
        　barB();
    });
    .finally(() => {
        　barC();
    });
```

この例では下記の順番で処理が実行されます。
（`barA`,`barB`,`barC`関数はそれぞれ任意の関数名です。）

1. `fetch`関数で`https://example.com`にリクエストを送信する。
2-A. リクエストが成功したら`barA`関数を実行する。
2-B. リクエストが失敗したら`barB`関数を実行する。
3. `barC`関数を実行する。

`then`と`catch`はリクエストの成功・失敗結果次第でどちらかのみ実行されますが、`finally`は成功・失敗に関わらず一番最後に必ず実行されます。
とくに必ず実行したい処理がない場合`finally`は省略してもOKですが、`then`と`catch`は両方必ず記述することをおすすめします。

また、`then`はサーバーサイドからのレスポンスが格納されている返り値`response`を返し、`catch`はエラー内容が格納されている返り値`error`を返します。これらを利用し、レスポンス内容に応じて処理を変えることも可能です。
例えばエラーが返ってきた場合にエラーのメッセージ内容を表示させるなどが考えられます。

```js
fetch("https://example.com")
    ...
    .catch((error) => {
        　console.log("エラーが発生しました。エラー内容は「" + error.message + "」です。");
    });
```

しかし、この構文は1つ欠点があります。コードをネストして書くため、連続して行いたい処理がもし複数ある場合には、可読性が悪くなってしまいます。
下記の例では、`fetch`関数で`https://example.com`にリクエストを送信した後、`/step1`というURLにリクエストを送信し、その後`/step2`というURLにリクエストを送信するという処理を行っていますが、ネスト構造が深くなってしまっています。
割愛しましたが、もしここに`catch`を加えるとさらにネスト構造が増えてしまいます。

```js
fetch("https://example.com")
    .then((response) => {
        fetch("https://example.com/step1").then((response) => {
            fetch("https://example.com/step2").then((response) => {
                console.log("全ての処理が完了しました。");
            　});
    })
    .catch((error) => {
        　console.log("エラーが発生しました。エラー内容は「" + error.message + "」です。");
    });
```

ほど複雑なプログラムを書かない限りこのようなネスト構造が深くなることはないと思いますが、一応この欠点は頭の片隅に置いてください。

--- 

【コラム】Promiseとは


--- 

--- 

【コラム】async / await構文とは
`then / catch / finally`と似たような構文に`async / await`および`try / catch / finally`構構文があります。
`then / catch / finally`構文よりも覚えることが多いのが難点ですが、これらはネスト構造が深くならない書き方ができるため、先に述べたようなデメリットを回避することが出来ます。
本書では詳しくは割愛しますが、JS中〜上級者以上を目指す場合には追々学習することをおすすめします。

- `async`: 関数の前につけることで、その関数を非同期処理にすることができる
- `await`: 非同期処理の前につけることで、その非同期処理が終わるまで次の処理を待機させることができる
- `try / catch / finally`: `try`の中に記述した処理を実行し、エラーが発生した場合は`catch`の中に記述した処理を実行する。`finally`は成功・失敗に関わらず必ず実行する。

コード例）
```js
const foo = async () => {
    try {
        await fetch("https://example.com");
        await fetch("https://example.com/step1");
        await fetch("https://example.com/step2");
        console.log("全ての処理が完了しました。");
    } catch (error) {
        console.log("エラーが発生しました。エラー内容は「" + error.message + "」です。");
    }
}
foo();
```

--- 

<!-- ### async / await + try / catch / finally 構文
もう1つ紹介したいのが`async / await`および`try / catch / finally`構文です。これは`then / catch`構文と同じように使うことができる構文です。

- `async`: 関数の前につけることで、その関数を非同期処理にすることができる
- `await`: 非同期処理の前につけることで、その非同期処理が終わるまで次の処理を待機させることができる
- `try / catch / finally`: `try`の中に記述した処理を実行し、エラーが発生した場合は`catch`の中に記述した処理を実行する。`finally`は成功・失敗に関わらず必ず実行する。

少々理解が難しいというデメリットがあるものの、3点メリットがあります。
メリットの1つは、__同期処理を非同期処理のように扱うことを可能にできる点__ 、2つ目は __非同期処理を同期処理のように制御することができる点__ です。
これにより、同期処理と非同期処理を混在させて扱う際にも実行順を正確に制御して扱うことができます。どういうことなのか、下記の例を見てみましょう。

```js
const foo = () => {
    const limit = 10000;
    for (let i = 0; i < limit; i++) {
        if(i == limit - 1){
            console.log("work A");
        }
    }
}
const bar = () => {
    console.log("work B");
}
foo(); // work A
bar(); // work B
```
これらは普通の関数です。同期処理として実行されるので、`foo()`の実行後に`bar()`が実行されます。


```js
const foo = async () => {
    const limit = 10000;
    for (let i = 0; i < limit; i++) {
        if(i == limit - 1){
            console.log("work A");
        }
    }
}

const foo = () => {
    console.log("work A");
}

setTimeout(() => {
    console.log("work B");
}, 1000);
foo();
```



1つはネストの必要がないので、可読性が高くなることです。
例えば、先程の`then / catch`構文で書いたコードを`async / await`構文で書き換えると下記のようになります。

```js
const foo = async () => {
    try {
        await fetch("https://example.com");
        await fetch("https://example.com/step1");
        await fetch("https://example.com/step2");
        console.log("全ての処理が完了しました。");
    } catch (error) {
        console.log("エラーが発生しました。エラー内容は「" + error.message + "」です。");
    }
}
foo();
```

`await`は非同期処理の前につけることで、その非同期処理が終わるまで次の処理を待機させることができる構文です。
つまりこの例では、`fetch("https://example.com")`が終わるまで`fetch("https://example.com/step1")`は実行されず、`fetch("https://example.com/step1")`が終わるまで`fetch("https://example.com/step2")`は実行されません。
ネストがなくなったことで、可読性が高くなったことがわかります。
ただし、`await`は`async`がついた関数の中でのみ使うことができるという制限があります。そのためこの例では、`foo`関数の前に`async`をつけています。



`async`は本来同期処理で実行される関数を非同期処理にするための構文です。関数の前に`async`をつけることで、その関数は非同期処理として実行されます。`fetch`のようにはじめから非同期処理として実行される関数はそのまま`await`をつけることができますが、普通の関数を非同期処理にする場合は`async`をつける必要があります。

ただし、`await`は`async`がついた関数の中でのみ使うことができるという制限があります。

これらの構文を使うことで、「処理1が終わるまで処理2は待機させる。処理1が終わったら処理2を実行する」といったことが可能になります。

まず、`async`は関数を非同期処理にするための構文です。関数の前に`async`をつけることで、その関数は非同期処理として実行されます。
また、`await`は非同期処理の前につけることで、その非同期処理が終わるまで次の処理を待機させることができる構文です。ただし、`await`は`async`がついた関数の中でのみ使うことができるという制限があります。

具体的なコード例を示しましょう。

```js
const foo = async () => {
    console.log("work A");

    await setTimeout(() => {
        console.log("work B");
    }, 1000);

    console.log("work C");
}

foo();
```

この場合、コンソールにはどの文字列がどの順番で表示されるでしょうか？
正解は下記の通りです。

```js
// work A
// work B
// work C
```


このような処理の流れを「同期処理」と呼びます。

async / await は、非同期処理を記述することができる構文の1つです。
async / await を使うことで、非同期処理を実行した後に次の処理を実行することができます。




<!-- そして、従来はこれをPHPやRubyなどのサーバーサイドのプログラムでのみ処理していました。
例えば古いタイプの掲示板のようなWebアプリケーションだと、記事を投稿する際、内容を入力して投稿ボタンを押すとページが切り替わった上で投稿が反映されます。

例えばその掲示版のURLが「https://keijiban.com」だとすると、これの仕組みは下記のようなものです。

- 1.投稿ページ（`https://keijiban.com/post`）にて、記事の内容を入力し、投稿ボタンを押す
- 2.最新記事が表示されるページ（`https://keijiban.com/page/1`）に遷移し、投稿した内容が反映される

このとき裏側では、
このような処理は、クライアントサイドで入力された内容をサーバーサイドに送信し、サーバーサイドでデータベースに保存するという流れで行われていました。 -->


--- 

【コラム】Promiseとは


--- 