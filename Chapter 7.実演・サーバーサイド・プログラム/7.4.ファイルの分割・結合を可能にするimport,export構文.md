# ファイルの分割・結合を可能にするimport,export構文
さて、Viteで作成されたプロジェクトを開くと、初期状態では`main.js`に`import`などと書かれていることが確認できるかと思います。
これら`import`と`export`はJS構文の1つで、Viteなどのビルドツールと合わせて使うことで効果を発揮する強力な機能です。
このあとFirebaseでのコーディングでも登場する機能なので、ここで簡単に内容を勉強しておきましょう。

具体的に何ができるようになるかというと、これらを使うことで開発時にファイルを分割し、可読性を高めることが出来ます。

## ファイルを分割・結合するメリットとデメリット
ファイルを分割して可読性を高めるとはどういうことなのか？例えば下記のようなコードを含むJSファイル`main.js`があったとします。

```js
const isLogin = () => {
    ...
}

const handleUser = (userStatus) => {
    ...
}

window.addEventListener('load', () => {
    const isLogin = isLogin();
    handleUser(isLogin);
});
```

isLoginはユーザーのログイン状態やタイプ（一般ユーザーか管理者かなど）を判定しその結果の情報を返す100行程度の関数だとします。  
handleUserは引数にユーザー情報を渡し、それによってさまざまな処理（ログイン中でなければトップページにリダイレクトするなど）を行う100行程度の関数だとします。
そしてこれらの関数を全ページでアクセス時に実行すべく、windowのロードのイベント時に合わせて実行しているとします。

このコードは非常に可読性が悪く、メンテナンス性も悪いといえます。なぜならisLoginとhandleUser異なる役割の関数が同じファイルに存在しており、しかも合わせて200行以上もの長さです。  
このように複数の役割持ってしまっている長文のコードは、読解するのに苦労するため、いざ後から修正・追記しようと思った際に時間がかかります。  

ではファイルを分割してそれぞれ読み込ませるのはどうでしょうか？
`main.js`をやめ、isLogin関数は`isLogin.js`、handleUser関数は`handleUser.js`に分けて記述し、それぞれ`<script>`タグで読み込ませるアプローチです。  
しかし残念ながらこれもよくないアプローチです。

ファイルを分けることとスコープ化させることは両立できません。分ける場合にはグローバルに記述することになりますが、それだと予期せぬエラーの原因になりやすいです。（Chapter 5.8参照）
また、ファイルを分けるとその分HTTP通信（Chapter 2.4参照）が増えるため、ローディングに時間がその分かかりパフォーマンス低下の要因になります。

そこで活用するのが`import`と`export`です。これらを使うと、ファイルを分割してコーディングしつつ、必要な部分（関数や変数など）だけを他のファイルから参照することができます。  
またViteなどのビルドツールを使うと、ビルド時に実行結果を変えることなくファイルを最小限に結合して出力してくれるため、ローディングの時間が増えることもありません。

## `import`と`export`の基本的な使い方
`import`と`export`は一対になっており、他のファイルで使えるようにしたい関数や変数に`export`を使い、呼び出したいファイルで`import`を使います。

まず、`export`は関数や変数の前につけることで有効になります。例えば`export-sample.js`というファイルがあるとして、そこに`export`で変数や関数を記述する場合は下記のようになります。

・export-sample.js
```js
//変数をexportする例
export const foo = "Hello World";

//関数をexportする例
export const bar = (txt) => {
    console.log(txt);
}; 
```

こうして`export`された変数や関数は、他のファイルで`import { 変数や関数名 } from "読み込み先ファイルのパス"`で読み込むことが出来ます。例えば`import-sample.js`というファイルがあるとして、そこに`import`で変数や関数を取り込む記述は下記のようになります。

・import-sample.js
```js
import { foo, bar } from "./export-sample.js";

bar(foo); //"Hello World"
```

この例では`export-sample.js`から変数`foo`と関数`bar`を`import`し、`import-sample.js`上で`bar`を実行しています。また引数に`import`した変数`foo`を指定しているので、実行結果はコンソール上に"Hello World"が出力されます。

なお、今回は`export-sample.js`と`import-sample.js`が同じディレクトリ階層にあると仮定してパスを`./`としましたが、ファイルがどの階層にあるかでこのパスは変わります。  
例えば`export-sample.js`が`import-sample.js`よりも1つ上の階層にあるとしたら、パスは`../`となり、`import { foo, bar } from "../export-sample.js";`を記述することになります。  
CursorなどのIDEでは自動補完によってパスを記述できるので、この場合でも積極的に頼りましょう。(Chapter 4.2参照)

なお、Viteでは拡張子の`.js`を省略して記述することができるので、下記のように書いてもOKです。

```js
import { foo, bar } from "./export-sample";
```

というわけで、先程のisLoginやhandleUserのコードは`import`, `export`を使うと下記のように買い替えることが可能です。

・isLogin.js
```js
export const isLogin = () => {
    ...
}
```

・handleUser.js
```js
export const handleUser = (userStatus) => {
    ...
}
```

・main.js
```js
import { isLogin } from "./isLogin"
import { handleUser } from "./handleUser"

window.addEventListener('load', () => {
    const isLogin = isLogin();
    handleUser(isLogin);
});
```

個々までの例では変数と関数に絞って説明をしましたが、そのほかにもクラス、配列、オブジェクトなどさまざまな要素に対して`import`と`export`は使うことが出来ます。
またこのほかにも、`import`と`export`にはさまざまな書き方ができます。

### `export`をまとめて記述する例
下記のように変数や関数を先に定義し、あとでまとめて`export`することもできます。
この書き方だと`export`の記述は1回で済むので、より簡潔に書くことが出来ます。

```js
const foo = "Hello World";
const bar = (txt) => {
    console.log(txt);
}; 

export { foo, bar };
```

### サードパーティ製のモジュールを`import`する場合
* サードパーティ製 ... 自分ではなく第三者の開発者や組織が開発・公開しているもの

npmモジュールのほとんどは内部的には関数やクラスに対し`export`が設定されているため、インストール後にそれらの`import`して扱います。  
例えばこのあとChapter 7.7以降ではFirebaseのnpmモジュールを利用することになりますが、その際に牡蠣のように記述して利用します。

```js
import { initializeApp } from "firebase/app";

const firebaseConfig = { ... }
const app = initializeApp(firebaseConfig);
```

Viteを利用している場合、`node_modules`にインストールされたnpmモジュールはパスを省略しての記述が可能です。  
